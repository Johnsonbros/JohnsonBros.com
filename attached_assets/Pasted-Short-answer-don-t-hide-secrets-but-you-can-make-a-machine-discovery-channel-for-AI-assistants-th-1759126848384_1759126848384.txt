Short answer: don’t hide secrets — but you can make a machine-discovery channel for AI assistants that’s unobtrusive to humans by publishing a machine-readable descriptor at a predictable location (or via HTTP headers) and gating useful details behind machine-friendly signals (headers, user-agent, auth). That keeps the public site clean while letting bots find your MCP/OpenAPI spec. Below are practical, safe, and ethical ways to do that, with examples you can drop into a server.

I’ll cover:
	1.	design principles & ethics
	2.	easiest options (low visibility to humans)
	3.	stronger, safer options (recommended)
	4.	concrete examples (HTTP Link header, .well-known file, nginx rule to serve only when a header exists)
	5.	checklist & cautions

1) Principles & ethics (non-negotiable)
	•	Be transparent about what you publish. If the spec exposes operations or private data, require authentication. Don’t publish credentials or private endpoints publicly.
	•	Use HTTPS always (TLS).
	•	Rate-limit and monitor access to the machine descriptor to detect abuse.
	•	If the descriptor is intended for partner AIs, use an access-control mechanism (API keys, signed requests, mTLS). Publicly discoverable but behind auth is a good pattern.
	•	Avoid deception: making something “invisible” should mean “not prominent in the UI,” not “hidden from legitimate inspection” or “evasion.” I can’t help with evading audit or law enforcement.

2) Easiest, low-visibility patterns (humans rarely see these)

These techniques make machine-discovery unobtrusive to human visitors — humans browsing normally rarely see them, but bots and assistants can find them.

A. .well-known file (recommended)
	•	Place a machine descriptor at a well-known URL such as https://example.com/.well-known/mcp-openapi.json or /.well-known/openapi.json. Humans won’t stumble on it during normal browsing, but clients can request it.
	•	Use a JSON OpenAPI file or a small JSON descriptor that points to the main API host.

B. HTTP Link header (very unobtrusive)
	•	Return an HTTP Link header on ordinary pages pointing to the machine descriptor. Browsers ignore it for display; programs can read it from headers. Example header:

Link: </.well-known/mcp-openapi.json>; rel="mcp"

Humans don’t see headers while reading the site; an assistant or crawler that inspects headers will.

C. Machine-only media type or Accept header
	•	Make the descriptor available at a resource that returns when the requester sends Accept: application/mcp+json (or Accept: application/openapi+json). Normal browsers won’t send that accept header, so casual human visits won’t fetch it.

D. application/ld+json block in HTML (low visibility, but visible in source)
	•	Add a small <script type="application/ld+json"> containing a minimal machine descriptor. Not shown on the page, but visible to anyone who views source. Less stealthy than .well-known or headers, but simple.

3) Stronger (safer & recommended) — discovery + gating

If you want it discoverable to trusted assistants, make discovery public but gate sensitive details:
	•	Place a public discovery descriptor (small JSON) at .well-known that only contains metadata and an authenticated endpoint URL. Example: .well-known/mcp.json contains { "api": "https://api.example.com/", "spec": "https://api.example.com/spec" } but the full spec endpoint requires an API key. That way humans don’t see boxes full of operational details and attackers can’t use the spec without auth.
	•	Require a custom header (e.g. X-MCP-Client: assistant-v1) and API key for the full spec. Assistants include the header as part of their client identity flow.
	•	Use short-lived tokens or signed requests (recommended) rather than static keys when possible.

4) Concrete examples you can use

A. .well-known file (minimal)
Place /.well-known/mcp.json:

{
  "name": "Acme MCP Discovery",
  "spec": "https://api.example.com/openapi.json",
  "contact": "ops@example.com",
  "notes": "Public discovery; spec endpoint requires auth"
}

Humans don’t see it except by URL or viewing site files.

B. HTTP Link header — example (server response)
Send this header on pages (or only on specific HTML responses):

Link: </.well-known/mcp.json>; rel="mcp"

Client code that checks headers can find rel="mcp" and then fetch the .well-known descriptor.

C. nginx example — serve spec only when a custom header is present
This serves /openapi.json only if incoming request has X-MCP-Client header. (Useful when you want to avoid casual discovery.)

server {
    listen 443 ssl;
    server_name example.com;

    # serve regular site...
    root /var/www/site;

    location = /openapi.json {
        # only allow if header present
        if ($http_x_mcp_client = "") {
            return 403;
        }
        # Optionally validate an API key header
        if ($http_x_api_key != "expected_key_value") {
            return 401;
        }
        alias /srv/api/openapi.json;
        add_header Content-Type application/json;
        # cache short time for performance
        add_header Cache-Control "private, max-age=60";
    }

    # .well-known endpoint exposed but tiny and non-sensitive
    location = /.well-known/mcp.json {
        alias /srv/.well-known/mcp.json;
        add_header Content-Type application/json;
        add_header Cache-Control "public, max-age=3600";
    }
}

D. Example assistant discovery flow (what a responsible assistant would do)
	1.	Request https://example.com/
	2.	Inspect response headers → find Link: … rel="mcp" → follow to /.well-known/mcp.json.
	3.	Read mcp.json; it shows spec URL.
	4.	Fetch spec with appropriate headers: X-MCP-Client: assistant-v1 and Authorization: Bearer <token>.
	5.	If 401/403, follow an authentication flow (OAuth, exchange client credentials, etc.).

E. curl demo to find descriptor via headers

# 1) request main page, show headers
curl -I https://example.com/

# 2) if Link header present, fetch .well-known descriptor
curl -s https://example.com/.well-known/mcp.json | jq .

5) Practical checklist (what to implement)
	•	Put a minimal discovery JSON at /.well-known/mcp.json.
	•	Add an HTTP Link header on pages that points to that well-known file.
	•	Host the full OpenAPI/spec on a separate endpoint that requires authentication.
	•	Use a custom header (e.g., X-MCP-Client) or Accept media type as a soft filter so regular browsers don’t automatically fetch the full spec.
	•	TLS everywhere; require auth for spec endpoints.
	•	Rate limit and log accesses; alert on unusual access patterns.
	•	Publish a basic developer contact in the .well-known file (for legitimate integrations).

6) Warnings & final thoughts
	•	If your goal is legitimate machine integration (partner AIs, internal assistants), this pattern is good: public discovery + gated details.
	•	If your goal is to deliberately hide functionality from auditors or regulators, I can’t assist.
	•	Security matters: a hidden spec is still sensitive. Require auth for anything that could enable misuse (creating jobs, reading customer data, etc.). Consider short-lived tokens and scopes.
	•	For Johnson Bros.: if you want the Housecall (or similar) integration to be found by authorized assistants, publish a small .well-known descriptor and require an API key for the real spec at api.housecallpro.com — that matches good practice.

Want a ready-to-deploy .well-known/mcp.json template plus the minimal nginx config file tailored to your domain (thejohnsonbros.com) and guidance for creating tokens? I can generate those files right now.